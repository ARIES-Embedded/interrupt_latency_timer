--
-- Interrupt Latency Timer
--
-- An APB slave device, capable to generate an interrupt request
-- signal and to count clock cycles till the request is acknowledged
-- by an ISR and/or received by an application program
--
-- Copyright (c) 2021 ARIES Embedded GmbH
--

library ieee;
use ieee.std_logic_1164.all;

use work.ilt_pkg.all;

entity ilt is
  generic (
    PADDR_WIDTH : integer := 32;
    PDATA_WIDTH : integer := 32;
    CORE_ID : std_logic_vector(31 downto 0) := x"%GIT_ID%"
  );
  port (
    pclk    : in  std_logic;
    presetn : in  std_logic;
    paddr   : in  std_logic_vector(PADDR_WIDTH-1 downto 0);
    pselx   : in  std_logic;
    penable : in  std_logic;
    pwrite  : in  std_logic;
    pwdata  : in  std_logic_vector(PDATA_WIDTH-1 downto 0);
    pready  : out std_logic;
    prdata  : out std_logic_vector(PDATA_WIDTH-1 downto 0);
    pslverr : out std_logic;
    irq     : out std_logic;
    test_a  : out std_logic;
    test_b  : out std_logic);
end entity ilt;

architecture struct of ilt is

  signal mctrl_w : std_logic;
  signal mctrl_data : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal mctrl_rd_data : std_logic_vector(PDATA_WIDTH-1 downto 0);

  signal gen_mode : std_logic_vector(1 downto 0) := "00";
  signal enable   : std_logic := '0';

  signal frt_latch : std_logic;
  signal frt_latch_clear : std_logic;
  signal frt_latch_l_valid, frt_latch_l_ovwr : std_logic;
  signal frt_latch_h_valid, frt_latch_h_ovwr : std_logic;
  signal frt_cnt_l : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal frt_cnt_h : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal frt_latch_l : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal frt_latch_h : std_logic_vector(PDATA_WIDTH-1 downto 0);

  signal r_d0 : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal r_d1 : std_logic_vector(PDATA_WIDTH-1 downto 0);  -- RFU
  signal r_d2 : std_logic_vector(PDATA_WIDTH-1 downto 0);  -- RFU
  signal r_d3 : std_logic_vector(PDATA_WIDTH-1 downto 0);  -- RFU

  signal latch0 : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal latch1 : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal latch2 : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal latch3 : std_logic_vector(PDATA_WIDTH-1 downto 0);

  signal l_busy : std_logic_vector(3 downto 0);
  signal l_ovfl : std_logic_vector(3 downto 0);

  signal ack0_mcnt : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal ack3_mcnt : std_logic_vector(PDATA_WIDTH-1 downto 0);

  type ilt_state_t is (ILT_IDLE_ST, ILT_DELAY_ST, ILT_ACTIVE_ST, ILT_ACK3_ST);
  signal ilt_state : ilt_state_t := ILT_IDLE_ST;
  signal ilt_next : ilt_state_t;

  signal d_cnt : std_logic_vector(PDATA_WIDTH-1 downto 0);
  signal l_cnt : std_logic_vector(PDATA_WIDTH-1 downto 0);

  signal nrst : std_logic;

begin

  irq <= '0';
  -- test_a <= '0';
  -- test_b <= '0';
  test_a <= gen_mode(0);
  test_b <= gen_mode(1);

  u0: component ilt_apb
    generic map (
      PADDR_WIDTH => PADDR_WIDTH,
      PDATA_WIDTH => PDATA_WIDTH)
    port map (
      pclk => pclk,
      presetn => presetn,
      paddr => paddr,
      pselx => pselx,
      penable => penable,
      pwrite => pwrite,
      pwdata => pwdata,
      pready => pready,
      prdata => prdata,
      pslverr => pslverr,

      mctrl_w => mctrl_w,
      mctrl_data =>mctrl_rd_data,

      core_id => CORE_ID,

      frt_latch_h => frt_latch_h,
      frt_latch_l => frt_latch_l,

      d_w => open,
      d_data => (others => (others => '0'))
      );

  u1: component ilt_register
    port map (
      clk  => pclk,
      nrst => presetn,
      wr   => mctrl_w,
      d    => pwdata,
      q    => mctrl_data);

  enable <= mctrl_data(PDATA_WIDTH-1);
  nrst <= presetn and enable;

  gen_mode <= mctrl_data(1 downto 0);

  mctrl_rd_data <= enable & "000" &
                   frt_latch_h_ovwr & frt_latch_l_ovwr &
                   frt_latch_h_valid & frt_latch_l_valid &
                   "00000000" &
                   "00000000" &
                   "000000" & gen_mode;

  u2: component ilt_frt
    port map (
      clk   => pclk,
      nrst  => nrst,
      cnt_h => frt_cnt_h,
      cnt_l => frt_cnt_l);

  frt_latch       <= pwdata(24) and mctrl_w;
  frt_latch_clear <= pwdata(25) and mctrl_w;

  u3: component ilt_latch
    port map (
      clk   => pclk,
      nrst  => nrst,
      clr   => frt_latch_clear,
      latch => frt_latch,
      d     => frt_cnt_h,
      q     => frt_latch_h,
      valid => frt_latch_h_valid,
      ovwr  => frt_latch_h_ovwr);

  u4: component ilt_latch
    port map (
      clk   => pclk,
      nrst  => nrst,
      clr   => frt_latch_clear,
      latch => frt_latch,
      d     => frt_cnt_l,
      q     => frt_latch_l,
      valid => frt_latch_l_valid,
      ovwr  => frt_latch_l_ovwr);

end architecture struct;
